using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniLang.Frontend;
using MiniLang.Util;
using System.IO;

namespace DfaGenerator
{
	public class DfaGenerator
	{
		public static readonly string WHITESPACE_CHARS = " \t\r";
		public static readonly string NEWLINE_CHARS = "\n";
		public static readonly char EOF_CHAR = '\0';

		public static void Main(string[] args)
		{
			using (StreamWriter outFile = new StreamWriter("LexerDfaTables.cs"))
			{
				outFile.WriteLine("// This file is generated by the DfaGenerator program. Do not modify!");
				outFile.WriteLine("namespace MiniLang.Frontend");
				outFile.WriteLine("{");
				outFile.WriteLine("\tpublic partial class Lexer");
				outFile.WriteLine("\t{");
				DfaVisualizer.Visualize(DoMain(outFile), "Main");
				DfaVisualizer.Visualize(DoComment(outFile), "Comment");
				outFile.WriteLine("\t}");
				outFile.WriteLine("}");
			}
		}
		private static byte[][] DoMain(StreamWriter sw)
		{
			DfaCreator c = new DfaCreator("MainParser");
			byte start = c.NewState();

			// Identifier: [a-zA-Z_][a-zA-Z_0-9]+
			// Also matches keywords
			byte ident = c.NewState();
			c.AddTransitionCharRange(start, ident, 'a', 'z');
			c.AddTransitionCharRange(start, ident, 'A', 'Z');
			c.AddTransition(start, ident, '_');

			c.AddTransitionCharRange(ident, ident, 'a', 'z');
			c.AddTransitionCharRange(ident, ident, 'A', 'Z');
			c.AddMultipleTransitions(ident, ident, "0123456789_");
			c.AddAcceptingTransition(ident, TokenType.Identifier);

			// IntLiteral: [0-9]+
			byte num = c.NewState();
			c.AddTransitionCharRange(start, num, '0', '9');
			c.AddTransitionCharRange(num, num, '0', '9');
			c.AddAcceptingTransition(num, TokenType.IntLiteral);

			// StringLiteral: "([^\\\n"]|\\\\|\\"|\\n)*"
			byte stringContent = c.NewState(),
				backslash = c.NewState();
			c.AddTransition(start, stringContent, '"');

			c.AddTransition(stringContent, backslash, '\\');
			c.AddReturnTransition(stringContent, '"', TokenType.StringLiteral);
			c.AddReturnTransition(stringContent, '\n', TokenType.UnterminatedStringLiteral); // newline in literals is not valid
			c.AddReturnTransition(stringContent, EOF_CHAR, TokenType.UnterminatedStringLiteral); // neither is EOF
			c.AddStarTransition(stringContent, stringContent);

			c.AddTransition(backslash, stringContent, '\\');
			c.AddTransition(backslash, stringContent, 'n');
			c.AddTransition(backslash, stringContent, '"');
			c.AddAcceptingTransition(backslash, TokenType.IllegalEscapeSequence);

			// Whitespace: [ \t\r]+
			// Newline: [ \t\r]*\n
			byte ws = c.NewState();
			c.AddMultipleTransitions(start, ws, WHITESPACE_CHARS);
			c.AddMultipleTransitions(ws, ws, WHITESPACE_CHARS);
			c.AddReturnTransition(ws, NEWLINE_CHARS, TokenType.Newline);
			c.AddAcceptingTransition(ws, TokenType.Whitespace);

			c.AddReturnTransition(start, NEWLINE_CHARS, TokenType.Newline);

			// operators
			c.AddDualCharOp(start, ":=", TokenType.Colon, TokenType.Assign);
			c.AddDualCharOp(start, "..", TokenType.Error, TokenType.DotDot);
			c.AddDualCharOp(start, "!=", TokenType.Not, TokenType.NE);
			c.AddDualCharOp(start, "<=", TokenType.LT, TokenType.LE);
			c.AddDualCharOp(start, ">=", TokenType.GT, TokenType.GE);
			c.AddReturnTransition(start, '(', TokenType.LeftParen);
			c.AddReturnTransition(start, ')', TokenType.RightParen);
			c.AddReturnTransition(start, ';', TokenType.Semicolon);
			c.AddReturnTransition(start, '+', TokenType.Plus);
			c.AddReturnTransition(start, '-', TokenType.Minus);
			c.AddReturnTransition(start, '*', TokenType.Times);
			c.AddReturnTransition(start, '&', TokenType.And);
			c.AddReturnTransition(start, '=', TokenType.EQ);

			// Divide: /
			// CommentStart: /\*
			// EOL comment: //[^\n]*(\n|$)
			byte slash = c.NewState(), eolComment = c.NewState();
			c.AddTransition(start, slash, '/');
			c.AddReturnTransition(slash, '*', TokenType.CommentStart);
			c.AddTransition(slash, eolComment, '/');
			c.AddAcceptingTransition(slash, TokenType.Div);

			c.AddReturnTransition(eolComment, NEWLINE_CHARS, TokenType.Newline);
			c.AddStarTransition(eolComment, eolComment);
			c.AddTransition(eolComment, (byte)(int)TokenType.Newline, EOF_CHAR);

			return c.Write(sw);
		}
		public static byte[][] DoComment(StreamWriter sw)
		{
			DfaCreator c = new DfaCreator("CommentParser");
			byte start = c.NewState(),
				  star = c.NewState(),
				  slash = c.NewState();
			c.AddReturnTransition(start, NEWLINE_CHARS, TokenType.Newline);
			c.AddTransition(start, star, '*');
			c.AddTransition(start, slash, '/');
			c.AddStarTransition(start, start);

			c.AddReturnTransition(star, NEWLINE_CHARS, TokenType.Newline);
			c.AddReturnTransition(star, '/', TokenType.CommentEnd);
			c.AddTransition(star, star, '*');
			c.AddStarTransition(star, start);

			c.AddReturnTransition(slash, NEWLINE_CHARS, TokenType.Newline);
			c.AddTransition(slash, slash, '/');
			c.AddReturnTransition(slash, '*', TokenType.CommentStart);
			c.AddStarTransition(slash, start);

			return c.Write(sw);
		}
	}
}
